%
% Time series analysis
% Assignment 
%
%

clear; 
close all;
% addpath('functions', '/data')         % Add this line to update the path
addpath('../functions', '../data')      % Add this line to update the path (Hanna)
%% 3. Modeling and validation for El-Geneina
clear
close all
clc

load proj23.mat

%% 3.1 Dividing and cleaning of data set
% Normalizing the data

y = ElGeneina.nvdi;
y_t = ElGeneina.nvdi_t;

max_data = 255;
min_data = 0;

y = 2*(y-min_data)/(max_data - min_data)-1;

figure
plot(y_t,y)
title('Normalized data')                % Data deemed stationary enough

figure
plot(y_t, ElGeneina.nvdi)
title('Original data')

%% 3.1 Dividing and cleaning of data set
% Examine the data's stationarity 
% Split into modelling, validation and test data

% Split the data
n = length(ElGeneina.nvdi);

ym = y(1:453,1);         % 70% for modelling
m_t = y_t(1:453,1);

yv = y(454:584,1);       % 20% for validation
v_t = y_t(454:584,1);

yt = y(585:end,1);        % 10% for test
t_t = y_t(585:end,1); 

% Plot it
figure(2)
subplot(311)
plot(m_t,ym);
title('Modeling set')
subplot(312)
plot(v_t,yv);
title('Validation set')
subplot(313)
plot(t_t,yt);
title('Test set')

%% 3.1 Dividing and cleaning of data set
% Examine outliers in modeling set -> looks fine
close all
clc

nbrLags = 100;
subplot(121)
acf(ym, nbrLags, 0.02 ,1);
hold on
tacf(ym, nbrLags, 0.02, 0.02 ,1);
hold off
title('ACF and TACF with alpha=0.02')

subplot(122)
acf(ym, nbrLags, 0.01 ,1);
hold on
tacf(ym, nbrLags, 0.01, 0.01 ,1);
hold off
title('ACF and TACF with alpha=0.01')
%% 3.2 Model B1 - NVDI prediction without external input
% Checking need for transformation
close all; 
clc; 

checkIfNormal(y,'Normalized NVDI','D',0.05)
bcNormPlot(y) % Suggests that taking the log might be a good idea

%% 3.2 Model B1 - NVDI prediction without external input
% Testing log transform
close all; 
clc; 

s
y_log = log(y);
checkIfNormal(y_log,'Log normalized NVDI','D',0.05) % Did the trick!

%%  3.2 Model B1 - NVDI prediction without external input
% Transformation of data 
close all; 
clc; 

ym_log = log(ym);
yv_log = log(yv);
yt_log = log(yt);
ym_yv = [ym; yv]; % Useful for prediction
ym_yv_t = [m_t; v_t];
ym_yv_log = log(ym_yv);
modelLim = length(ym)+1; % Index for first data in validation set
plot(ym_yv_t, ym_yv)

%%  3.2 Model B1 - NVDI prediction without external input
% Differentiation of the data; 
clc; 
close all; 
noLags = 50;                % max up to N/4

plotACFnPACF(ym_log,noLags, 'model data');

% Differentiate on season 36 with nabla (1-z^-36)
A36 = [1 zeros(1,35) -1];                       % Sets the season
ym_diff = filter(A36,1,ym_log);                   % Filter on seasonality 36 
ym_diff = ym_diff(length(A36):end);               % Omit initial samples
data = iddata(ym_diff);                          % Create object for estimation
figure()
plot(ym_diff);
plotACFnPACF(ym_diff, noLags, "model data after differentiation with nabla36");
mean(ym_diff)

% Also tested "softer" differentiation, to better result but non-zero mean:

% Differentiate on season 36 with (1-0.35*z^-36)
% A36 = [1 zeros(1,35) -0.35];                     % Sets the season
% m_diff = filter(A36,1,ym_log);                    % Filter on seasonality 36 
% m_diff = m_diff(length(A36):end);                % Omit initial samples
% data = iddata(m_diff);                           % Create object for estimation
% plotACFnPACF(m_diff, noLags, "model data with a36 = 0.35");  
% figure()
% plot(m_diff);
% mean(m_diff)
% 
% % Remove mean of differentiated data
% m_diff_mean = m_diff - mean(m_diff);            % Note! This mean will prob not be same for validation and so on 
% % m_diff_mean = m_diff;
% figure()
% plot(m_diff_mean)

%%  3.2 Model B1 - NVDI prediction without external input
% Model the data after differentiating the data - using differentiation of
% -1 to get zero-mean
close all; 
clc;
noLags = 50; 

% Initial model - try a1
A = [1 0];
C = 1;
ym_diff_d = iddata(ym_diff);

model_init = idpoly(A, [], C);               % Set up initial model
model_ar = pem(ym_diff_d, model_init);       % Optimize variables 
res = resid(model_ar, ym_diff_d);            % Calculate residuals 
plotACFnPACF(res.y, noLags, "Residual for AR(1) modelling");
figure()
present(model_ar);
whitenessTest(res.y);
checkIfNormal(res.y,'Residuals for AR(1)');
plotNTdist(res.y);

% FPE: 0.04411 and Monti: 28.47 < 36.42
% OBS! Residual not normal --> can't 100 procent trust result.
% The residual is however t-dstriuted, even wider confidence interval for
% testing whiteness, so it is OK! 
% ACF & PACF --> Maybe include c36 or/and c3? 

%%  3.2 Model B1 - NVDI prediction without external input
% Although white, a bit of a peak at 36 still -> try a1 & c36

A = [1 0];
C = [1 zeros(1,36)];

model_init = idpoly(A, [], C);                          % Set up initial model
model_init.Structure.c.Free = [0 zeros(1,35) 1];        % added ones C changed
model_arma = pem(ym_diff_d, model_init);                % Optimize variables 
res = resid(model_arma, ym_diff_d);                     % Calculate residuals 
plotACFnPACF(res.y, noLags, "Residual for a1 and c36 modelling");
figure()
present(model_arma);
whitenessTest(res.y);
checkIfNormal(res.y,'Residuals for a1 and c36 modelling');
plotNTdist(res.y);

% FPE: 0.04292 and Monti: 30.74 < 36.42
% All significant, not white residuals

%% 3.2 Model B1 - NVDI prediction without external input
% Although white, a bit of a peak at 36 still -> try a1, c3 & c36
A = [1 0];
C = [1 zeros(1,36)];

model_init = idpoly(A, [], C);                       % Set up initial model
model_init.Structure.c.Free = [0 0 0 1 zeros(1,32) 1];        % added ones C changed
model_arma = pem(ym_diff_d, model_init);       % Optimize variables 
res = resid(model_arma, ym_diff_d);            % Calculate residuals 
plotACFnPACF(res.y, noLags, "Residual for a1, c3, and c36 modelling");
figure()
present(model_arma);
whitenessTest(res.y);
checkIfNormal(res.y,'Residuals for a1, c3, and c36 modelling');
plotNTdist(res.y);
% FPE: 0.04254 and Monti: 28.84 < 36.42
% C3 insignificant --> KISS rule 

%% 3.2 Model B1 - NVDI prediction without external input
% Substituting c36 with c3 only? To make it more simple

A = [1 0];
C = [1 0 0 1];

model_init = idpoly(A, [], C);                       % Set up initial model
model_init.Structure.c.Free = [0 0 0 1];        % added ones C changed
model_arma = pem(ym_diff_d, model_init);       % Optimize variables 
res = resid(model_arma, ym_diff_d);            % Calculate residuals 
plotACFnPACF(res.y, noLags, "Residual for a1 and c3 modelling");
figure()
present(model_arma);
whitenessTest(res.y);
checkIfNormal(res.y,'Residuals for a1 and c3 modelling');
plotNTdist(res.y);
% FPE: 0.04409 and Monti: 22.00 < 36.42
% ACF and PACF shows season of 36, however - more white than ever. We test
% to incorporate season instead and leave c36 out

%%  3.2 Model B1 - NVDI prediction without external input
% Model data without differentiation (incorporating the season)
close all; 
clc; 

noLags = 50; 

% initial model - based on information from differentiated
A = [1 0];
A = conv([1 zeros(1,35) -1], A);
C = [1 0 0 1];

ym_log_d = iddata(ym_log); % Not using differentiated data anymore

model_init = idpoly(A, [], C);
model_init.Structure.a.Free = [0 1 zeros(1,34) 1 0];        
model_init.Structure.c.Free = [zeros(1,3) 1];            
model_B1 = pem(ym_log_d, model_init);                     
res = resid(model_B1, ym_log_d);
plotACFnPACF(res.y, noLags, "Residual for SARIMA modelling");

figure()
present(model_B1);
whitenessTest(res.y);
checkIfNormal(res.y,'Residuals from SARIMA modelling');
plotNTdist(res.y);
% FPE: 0.04658 and Monti: 8.89 < 36.42
% Best one so far
% All significant, however, t-distributed residuals

%% 3.2.2. Model prediction
% Predict the vegetation using the derived final model
clc
close all

k = 7;                  % sets number of steps prediction
noLags = 50;

% Solve the Diophantine equation and create predictions
[Fx, Gx] = polydiv(model_B1.c, model_B1.a, k);
throw = max(length(Gx), length(model_B1.c));
yhat_k = filter(Gx, model_B1.c, ym_yv_log);

yhat_k_org = exp(yhat_k);

figure
plot([ym_yv yhat_k_org] )
line( [modelLim modelLim], [-1e6 1e6 ], 'Color','red','LineStyle',':' )
legend('NVDI', 'Predicted NVDI', 'Prediction starts')
title( sprintf('Predicted NVDI, y_{t+%i|t}', k) )
axis([1 length(ym_yv) min(ym_yv)*1.5 max(ym_yv)*1.5])

%std_xk = sqrt( sum( Fx.^2 )*var_ex );
%fprintf( 'The theoretical std of the %i-step prediction error is %4.2f.\n', k, std_xk)

%% 3.2.2 Model prediction
% Form the residual for the validation data. It should behave as an MA(k-1)
ehat = ym_yv - yhat_k_org;
ehat = ehat(modelLim:end);

figure
acf( ehat, nbrLags, 0.05, 1 );
title( sprintf('ACF of the %i-step prediction residual', k) )
fprintf('This is a %i-step prediction. Ideally, the residual should be an MA(%i) process.\n', k, k-1)
checkIfWhite( ehat );
pacfEst = pacf( ehat, nbrLags, 0.05 );
checkIfNormal( pacfEst(k+1:end), 'PACF' );

%% HANNA ->
%% 3.2.2. Model prediction
% Lets do a one step and save the variance
k = 1;      % prediction step 

[Fk, Gk] = polydiv(model_sarima.c, model_sarima.a, k );  
throw = max(length(Gk), length(model_sarima.c));
yhat_1 = filter(Gk, model_sarima.c, v_log);                             
yhat_1 = yhat_1(throw:end);   
yhat_1_org = exp(yhat_1);
var_1 = var(v(throw:end) - yhat_1_org)
var_test = var(v_log(throw:end) - yhat_1)

basicPlot(e, 50, 'e')

e = v(throw:end) - yhat_1_org;          % Calculating our error terms that we expect to behave like an MA
eps = myFilter(Fk, 1, e);               % Removing the MA-part, to see if white. 
basicPlot(eps, 50, 'Stationary prediction error') % It is!


%%  3.2.2 Model prediction (B1) 
close all; 
clc; 
k = 45;                  % sets number of steps prediction

% Solve the Diophantine equation and create predictions
[Fk, Gk] = polydiv(model_sarima.c, model_sarima.a, k);
throw = max(length(Gk), length(model_sarima.c));
yhat_k = filter(Gk, model_sarima.c, v_log);
yhat_k = yhat_k(throw:end);

% Transform prediction into original domain
yhat_k_org = exp(yhat_k);

% It can be seen that the shift is IN GENERAL this (and is fun to then
% incorporate to be able to plot for both shifted and non shifted
if k == 1 || k == 2
    shift = k; 
else 
    shift = 3; 
end

% Create the errors (shifted and unshifted, original domain vs not) 
error_shifted = v_log(throw:end-shift) - yhat_k(1+shift:end);
error_org_shifted = v(throw:end-shift) - yhat_k_org(1+shift:end);
error = v_log(throw:end) - yhat_k;
error_org = v(throw:end) - yhat_k_org;
var(error)
var(error_shifted)
var(error_org)
var(error_org_shifted)

% Original domain plot (not shifted)
figure()
hold on
plot(yhat_k_org,'g');
plot(v(throw:end));
hold off
basicPlot(error_org,noLags,'Original domain not shifted')

% Original domain plot (shifted)
figure()
hold on
plot(yhat_k_org(1+shift:end),'g');
plot(v(throw:end-shift));
hold off
basicPlot(error_org,noLags,'Original domain')

% VETY UNSURE!!! Lets compare it to the theoretical variance (VERY UNSURE OF THIS- not
% even normal distributed)
theoretical_variance = sum(Fk.^2) * var_1
conf = 2*sqrt(theoretical_variance);
conf_int = [0-conf, 0+conf]
error_outside = (sum(error_org>conf_int(2)) + sum(error_org<conf_int(1)))/length(error_org)

